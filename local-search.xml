<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>out_of_bounds</title>
    <link href="/2021/11/02/out-of-bounds/"/>
    <url>/2021/11/02/out-of-bounds/</url>
    
    <content type="html"><![CDATA[<p>LeetCode 报错：Line 1034: Char 9: runtime error: reference binding to null pointer of type ‘int’ (stl_vector.h)  </p><span id="more"></span><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>LeetCode 刷题遇到 Line 1034: Char 9: runtime error: reference binding to null pointer of type ‘int’ (stl_vector.h)等类似问题  </p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>该主要引起的原因是vector容器出现空指针，而导致了越界<br>在做题时，我先取了vector容器的首位，即vector[0]，然后再进行<em>nums.size() == 0</em>的判断，于是就出现了报错  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">错误：<br>vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums;<br><span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> compare = nums[<span class="hljs-number">0</span>]; <br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>vector在还没有分配任何空间时不能像数组一样用下标形式去访问vector，就算是vector[0]也不行，编译能通过，运行后就会runtime error</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>将<em>nums.size() == 0</em>的判断放到最前面  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">修改后：<br>vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums;<br><span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> compare = nums[<span class="hljs-number">0</span>]; <br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>数组为静态分配内存，创建时需确定大小然后给它分配空间，但vector是动态数组，允许跳过分配创建且编译无问题，但运行就报错，即runtime error<br>在使用vector时，应该先进行push_back()或直接对容器赋值等形式，分配空间后，才能用类似数组的[]形式访问</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BitOperation</title>
    <link href="/2021/10/25/BitOperation/"/>
    <url>/2021/10/25/BitOperation/</url>
    
    <content type="html"><![CDATA[<p>左移(&lt;&lt;)与右移(&gt;&gt;)</p><span id="more"></span><h1 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h1><p>以8位二进制为例：15&lt;&lt;2<br>十进制15转化为8位二进制为00001111，左移2位，舍弃高位，低位补0，即00111100<br>左移N位相当于该数乘以2的N次方，但只适用于该数左移时被溢出舍弃的高位中不包含1的情况  </p><p>补充：<br>负数的二进制为其绝对值的二进制的补码（反码加1）  </p><h1 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h1><p>对无符号数,右移时左边高位补0<br>对于有符号数，符号位为0(即正),则左边也是补0。符号位为1(即负)，则左边补0还是1，要取决于所用的计算机系统，补0的称为“逻辑移位”，即简单位，补1的称为“算术移位”  </p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python PEP 8</title>
    <link href="/2021/08/27/python%E8%A7%84%E8%8C%83%E5%8F%8APEP%208/"/>
    <url>/2021/08/27/python%E8%A7%84%E8%8C%83%E5%8F%8APEP%208/</url>
    
    <content type="html"><![CDATA[<p>python规范及PEP 8 </p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每当使用pycharm的时候总能在右边看到黄杠杠，并且在代码中伴随这各种波浪线提示或者警告，我很快联想到了Word也有类似的波浪线提示，并且能够关掉（重点），于是经过简单的搜索就找到了解决办法————点击右下角小人就可以打开代码高亮的设置修改为syntax(语法)就可以了，默认为inspection(检查)<br><br>解决之后，我就在想这是一个怎样的规定让我的代码总有黄杠杠提示，我将鼠标多次放在不同的黄杠杠之上后，提示信息的开头大多都是<strong>PEP 8：</strong> 于是，经过google后认识了PEP 8规范，并以翻译官方文档为基础通过本篇做一个总结记录  </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>PEP 8</strong>是Python社区通用的风格指南，起初为Python之父——Guido van Rossum自己的编写代码风格，经过时间的演变成现如今的一套较为成熟的编码规范，coder则在这个规范的基础上结合自身习惯和开发环境来写出更具有可读性的代码，而pycharm引入了这一套规范来提示使用者有个良好的编写风格<br>PEP 8官方文档——<a href="https://pep8.org/">PEP 8</a></p><h1 id="代码布局"><a href="#代码布局" class="headerlink" title="代码布局"></a>代码布局</h1><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>每个缩进级使用4个空格<br><br>连续行应该使用Python的隐式续行，即垂直对齐于()、[/]或者{}，另外也可以使用悬空缩进，当使用悬空缩进时：第一行不应该带有参数，使用进一步的缩进来明确区分自己是一个延续行<br>正确示例：  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Aligned with opening delimiter.</span><br>foo = long_function_name(var_one, var_two,<br>                         var_three, var_four)<br><br><span class="hljs-comment"># More indentation included to distinguish this from the rest.</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_function_name</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        var_one, var_two, var_three,</span></span><br><span class="hljs-params"><span class="hljs-function">        var_four</span>):</span><br>    <span class="hljs-built_in">print</span>(var_one)<br><br><span class="hljs-comment"># Hanging indents should add a level.</span><br>foo = long_function_name(<br>    var_one, var_two,<br>    var_three, var_four)<br></code></pre></td></tr></table></figure><p>错误示例：  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Aligned with opening delimiter.</span><br>foo = long_function_name(var_one, var_two,<br>                         var_three, var_four)<br><br><span class="hljs-comment"># More indentation included to distinguish this from the rest.</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_function_name</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        var_one, var_two, var_three,</span></span><br><span class="hljs-params"><span class="hljs-function">        var_four</span>):</span><br>    <span class="hljs-built_in">print</span>(var_one)<br><br><span class="hljs-comment"># Hanging indents should add a level.</span><br>foo = long_function_name(<br>    var_one, var_two,<br>    var_three, var_four)<br></code></pre></td></tr></table></figure><p>tip：对于续行来说，4个空格的规则可以不必遵守  </p><h2 id="Tabs-or-Spaces"><a href="#Tabs-or-Spaces" class="headerlink" title="Tabs or Spaces"></a>Tabs or Spaces</h2><p>空格是更好的缩进选择<br><br>Tab在不同的编辑器的长度是不同的，如今大多数IDE都对Tab进行了各种的优化，例如将Tab展开为空格，但是还是Tab在不同的环境下还是会出现不同的展现，而空格数却保持一致，对使用空格更加精确，切记绝对不能Tab和空格混用  </p><h2 id="代码行最大长度"><a href="#代码行最大长度" class="headerlink" title="代码行最大长度"></a>代码行最大长度</h2><p>所有行所限制的最大字符数为79，没有结构化的大块文本(如文档字符或注释)限制为72个字符；较长的代码行可以通过括号来隐性续行或者采用反斜杠方式续行  </p><h2 id="二元运算符换行"><a href="#二元运算符换行" class="headerlink" title="二元运算符换行"></a>二元运算符换行</h2><p>Python 代码中，只要前后保持一致，在二元操作符之前或之后换行都可以。推荐使用在二元运算符之前换行的风格  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">income = (gross_wages<br>          + taxable_interest<br>          + (dividends - qualified_dividends)<br>          - ira_deduction<br>          - student_loan_interest)<br></code></pre></td></tr></table></figure><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><ul><li>顶层函数和类的定义使用两个空行间隔  </li><li>类里面的方法定义使用一个空格间隔  </li><li>可使用额外空行(少量)来分隔一组相关函数；在相关的仅一行的函数之间，空行可被省略(如一组虚函数定义)  </li><li>在函数内使用空行(少量)来使代码逻辑更清晰</li></ul><p>Python支持control-L（如:^L）换页符作为空格。许多工具将这些符号作为分页符，用来分页或者区分文件中的相关区域。但是，一些编辑器和基于web的代码预览器可能不会将control-L识别为分页符，变成其他符号  </p><h2 id="源文件编码"><a href="#源文件编码" class="headerlink" title="源文件编码"></a>源文件编码</h2><p>Python核心发行版中的代码一直使用UTF-8（Python 2中使用ASCII），因此，使用ASCII（Python 2）或者UTF-8（Python 3）的文件不应该添加编码声明<br><br>在标准库中，只有测试、注释或文档字符串需要提及作者名字包含ASCII字符时，才能使用非默认的编码，否则使用转义字符来代替<br><br>Python标准库中的所有标识符都必须只采用ASCII编码的标识符，在可行的条件下也应当使用英文词（很多情况下，使用的缩写和技术术语词都不是英文）。此外，字符串文字和注释应该只包括ASCII编码。只有两种例外：  </p><ol><li>测试情况下为了测试非ASCII编码的特性  </li><li>作者名字不是由拉丁字母组成的也必须提供一个拉丁音译名</li></ol><p>鼓励具有全球受众的开放源码项目采用类似的原则  </p><h2 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h2><p>导入语句一般放在文件开头，在模块注释和文档字符串之后，模块全局变量和常量之前  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> Popen, PIPE<br></code></pre></td></tr></table></figure><p>模块导入应该注意顺序：  </p><ul><li>标准库导入</li><li>相关的第三方包导入</li><li>本地应用或库的特定导入</li></ul><p>tip：在每一组导入之间加入空行<br></p><p>推荐使用绝对路径导入方式，这样更有可读性，在系统配置错误时的情况下至少会给出更好的错误提示信息<br>然而，清晰的相对路径导入方式也是可以的，特别是当包的结构比较复杂，使用绝对路径导入方式反而会使代码显得冗杂<br>标准库的代码没有复杂的包结构，并且一直使用绝对路径的导入方式，不能使用隐式的相对路径导入，在Python3 中已经被移除<br><br>当从包含类的模块中导入类时，可以使用以下写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> myclass<br><span class="hljs-keyword">import</span> foo.bar.yourclass<br></code></pre></td></tr></table></figure><p>然后使用myclass.MyClass 或者foo.bar.yourclass.YourClass<br></p><p>避免使用通配符的方式导入（from <module> import *），因为这会使当前命名空间中的名称含义不清晰，给读者和许多自动化工具造成困扰。有一种情况正当使用通配符导入的情形，就是将一个内部接口重新发布作为公共API（比如，使用可选的加速模块中的定义覆盖纯Python实现的接口，预先无法知晓具体哪些定义将被覆盖）<br><br>当使用这种方式重新发布名称时，本篇关于公共和内部接口的部分仍然适用  </p><h2 id="模块双下划线名称"><a href="#模块双下划线名称" class="headerlink" title="模块双下划线名称"></a>模块双下划线名称</h2><p>模块中的“双下划线”（变量名以两个下划线开头，两个下划线结尾）变量，比如__all__，__author，__version__等，应该写在文档字符串(docstring)之后，并且在除了form __future__引用(imports)的任何其它类型的引用语句之前。Python要求模块中__future__的导入必须出现在除文档字符串(docstring)之外的任何其他代码之前  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">This is the example module.</span><br><span class="hljs-string">This module does stuff.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> barry_as_FLUFL<br><br>__all__ = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br>__version__ = <span class="hljs-string">&#x27;0.1&#x27;</span><br>__author__ = <span class="hljs-string">&#x27;Cardinal Biggles&#x27;</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br></code></pre></td></tr></table></figure><h1 id="字符串引用"><a href="#字符串引用" class="headerlink" title="字符串引用"></a>字符串引用</h1><p>Python中表示字符串时，不管用单引号还是双引号都是一样的。但不建议且混用，最好是一直使用一种表达方式。当字符串中包含单引号时，则采用双引号来表示字符串，反之亦然，这样就可以避免使用反斜杠，提高可读性<br><br>对于三引号表示的字符串，使用双引号字符来表示，这样可以和PEP 257的文档字符串（docstring）规则保持一致  </p><h1 id="表达式和语句中的空格"><a href="#表达式和语句中的空格" class="headerlink" title="表达式和语句中的空格"></a>表达式和语句中的空格</h1><h2 id="Pet-Peeves"><a href="#Pet-Peeves" class="headerlink" title="Pet Peeves"></a>Pet Peeves</h2><p>即不能忍受的事情或厌恶的事<br><br>在下列情况下尽量避免使用过多空格：  </p><ol><li><p>括号内挨着括号的地方(包括圆括号，方括号，花括号)  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>spam(ham[<span class="hljs-number">1</span>], &#123;eggs: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment"># NO：</span><br>spam( ham[ <span class="hljs-number">1</span> ], &#123; eggs: <span class="hljs-number">2</span> &#125; )<br></code></pre></td></tr></table></figure></li><li><p> 逗号后面接右括号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>foo = (<span class="hljs-number">0</span>,)<br><span class="hljs-comment"># No：</span><br>bar = (<span class="hljs-number">0</span>, )<br></code></pre></td></tr></table></figure></li><li><p>逗号，分号和冒号之前</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">4</span>: <span class="hljs-built_in">print</span> x, y; x, y = y, x<br><span class="hljs-comment"># No：</span><br><span class="hljs-keyword">if</span> x == <span class="hljs-number">4</span> : <span class="hljs-built_in">print</span> x , y ; x , y = y , x<br></code></pre></td></tr></table></figure></li><li><p>切片操作中冒号为二目运算符，两边应该具有相同的空格数(把它当做优先级最低的操作符)，在扩展切片操作中，两个冒号左右两边的空格数应保持一致（若切片操作省略了参数，则同样省略空格）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>ham[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>], ham[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>:<span class="hljs-number">3</span>], ham[:<span class="hljs-number">9</span>:<span class="hljs-number">3</span>], ham[<span class="hljs-number">1</span>::<span class="hljs-number">3</span>], ham[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>:]<br>ham[lower:upper], ham[lower:upper:], ham[lower::step]<br>ham[lower+offset : upper+offset]<br>ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]<br>ham[lower + offset : upper + offset]<br><br><span class="hljs-comment"># No：</span><br>ham[lower + offset:upper + offset]<br>ham[<span class="hljs-number">1</span>: <span class="hljs-number">9</span>], ham[<span class="hljs-number">1</span> :<span class="hljs-number">9</span>], ham[<span class="hljs-number">1</span>:<span class="hljs-number">9</span> :<span class="hljs-number">3</span>]<br>ham[lower : : upper]<br>ham[ : upper]<br></code></pre></td></tr></table></figure></li><li><p>函数的参数括号前</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>spam(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># No：</span><br>spam (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li><p>索引或切片操作的左括号前</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>dct[<span class="hljs-string">&#x27;key&#x27;</span>] = lst[index]<br><span class="hljs-comment"># No：</span><br>dct [<span class="hljs-string">&#x27;key&#x27;</span>] = lst [index]<br></code></pre></td></tr></table></figure></li><li><p>为对齐在赋值运算符等两侧增加多余空格</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>x = <span class="hljs-number">1</span><br>y = <span class="hljs-number">2</span><br>long_variable = <span class="hljs-number">3</span><br><br><span class="hljs-comment"># No：</span><br>x             = <span class="hljs-number">1</span><br>y             = <span class="hljs-number">2</span><br>long_variable = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="其他建议"><a href="#其他建议" class="headerlink" title="其他建议"></a>其他建议</h2><p>避免在行的末尾添加空格，因为尾部的空格通常都看不见，容易产生混乱；如：一个反斜杠\后面跟一个空格和新的一行，那么\就不会算作续行符。有些编辑器会自动去掉行末的空格，并且很多项目（像CPython）会用pre-commit hooks来预防<br><br>二目运算符两边通常保留一个空格，如：赋值运算符（=），增强的复制运算符（+=，-=等）关系运算符（==，&lt;，&gt;，!=，&lt;=，&gt;=，in，not in，is，is not），布尔运算符（and，or，not）<br></p><ol><li><p>如果使用了优先级不同的运算符则可以在低优先级运算符两侧增加一个空格(结合实际添加，不建议超过一个空格)，但是，在二目运算符的两边空格数应保持一致</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br>i = i + <span class="hljs-number">1</span><br>submitted += <span class="hljs-number">1</span><br>x = x*<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>hypot2 = x*x + y*y<br>c = (a+b) * (a-b)<br><br><span class="hljs-comment"># No:</span><br>i=i+<span class="hljs-number">1</span><br>submitted +=<span class="hljs-number">1</span><br>x = x * <span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>hypot2 = x * x + y * y<br>c = (a + b) * (a - b)<br></code></pre></td></tr></table></figure></li><li><p>在使用关键字参数或者默认参数时，等号两边不加空格</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complex</span>(<span class="hljs-params">real, imag=<span class="hljs-number">0.0</span></span>):</span><br>    <span class="hljs-keyword">return</span> magic(r=real, i=imag)<br><span class="hljs-comment"># No:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">complex</span>(<span class="hljs-params">real, imag = <span class="hljs-number">0.0</span></span>):</span><br>    <span class="hljs-keyword">return</span> magic(r = real, i = imag)<br></code></pre></td></tr></table></figure></li><li><p>函数注释中的冒号遵循一般的加空格的规则，如果有箭头，在其两边加空格（详见下文函数注释部分）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>: AnyStr</span>):</span> ...<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>() -&gt; AnyStr:</span> ...<br><br><span class="hljs-comment"># No：</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>:AnyStr</span>):</span> ...<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>()-&gt;PosInt:</span> ...<br></code></pre></td></tr></table></figure></li><li><p>当同时使用参数注释和参数默认值时，赋值符号两边要加空格（但仅对既有空格又有默认值的参数成立）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params">sep: AnyStr = <span class="hljs-literal">None</span></span>):</span> ...<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>: AnyStr, sep: AnyStr = <span class="hljs-literal">None</span>, limit=<span class="hljs-number">1000</span></span>):</span> ...<br><br><span class="hljs-comment"># No:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>: AnyStr=<span class="hljs-literal">None</span></span>):</span> ...<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">munge</span>(<span class="hljs-params"><span class="hljs-built_in">input</span>: AnyStr, limit = <span class="hljs-number">1000</span></span>):</span> ...<br></code></pre></td></tr></table></figure></li><li><p>通常不建议使用复合语句（即将多条语句写在一行）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-keyword">if</span> foo == <span class="hljs-string">&#x27;blah&#x27;</span>:<br>  do_blah_thing()<br>do_one()<br>do_two()<br>do_three()<br><br><span class="hljs-comment"># Rather not：</span><br><span class="hljs-keyword">if</span> foo == <span class="hljs-string">&#x27;blah&#x27;</span>: do_blah_thing()<br>do_one(); do_two(); do_three() <br></code></pre></td></tr></table></figure></li><li><p>小型的if/for/whiel语句放在一行是可以的，但是有多条分句时不要这样做，同时要避免无谓的换行！</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Rather not：</span><br><span class="hljs-keyword">if</span> foo == <span class="hljs-string">&#x27;blah&#x27;</span>: do_blah_thing()<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> lst: total += x<br><span class="hljs-keyword">while</span> t &lt; <span class="hljs-number">10</span>: t = delay()<br><br><span class="hljs-comment"># Definitely not：</span><br><span class="hljs-keyword">if</span> foo == <span class="hljs-string">&#x27;blah&#x27;</span>: do_blah_thing()<br><span class="hljs-keyword">else</span>: do_non_blah_thing()<br><span class="hljs-keyword">try</span>: something()<br><span class="hljs-keyword">finally</span>: cleanup()<br>do_one(); do_two(); do_three(long, argument,<br>                           <span class="hljs-built_in">list</span>, like, this)<br><span class="hljs-keyword">if</span> foo == <span class="hljs-string">&#x27;blah&#x27;</span>: one(); two(); three()<br></code></pre></td></tr></table></figure></li></ol><h1 id="何时在末尾加逗号"><a href="#何时在末尾加逗号" class="headerlink" title="何时在末尾加逗号"></a>何时在末尾加逗号</h1><p>末尾的逗号通常是可选的，但在定义单元素元组时是必须的（Python2中，逗号对print语句有特殊语义），因此建议使用括号括起来（这个在技术上是冗余的）  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br>FILES = (<span class="hljs-string">&#x27;setup.cfg&#x27;</span>,)<br><br><span class="hljs-comment"># OK, but confusing：</span><br>FILES = <span class="hljs-string">&#x27;setup.cfg&#x27;</span>,<br></code></pre></td></tr></table></figure><p>当使用版本控制系统时，在以后有可能还会增加的值和参数列表或导入条目的末尾添加多余的逗号是有好处的<br>每行只写一个值再加逗号，在最后加新行写上右括号，不过，把逗号和右括号写在同一行就没有意义了（上面提到的单元素元组除外）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br>FILES = [<br>    <span class="hljs-string">&#x27;setup.cfg&#x27;</span>,<br>    <span class="hljs-string">&#x27;tox.ini&#x27;</span>,<br>    ]<br>initialize(FILES,<br>           error=<span class="hljs-literal">True</span>,<br>           )<br><span class="hljs-comment"># No:</span><br>FILES = [<span class="hljs-string">&#x27;setup.cfg&#x27;</span>, <span class="hljs-string">&#x27;tox.ini&#x27;</span>,]<br>initialize(FILES, error=<span class="hljs-literal">True</span>,)<br></code></pre></td></tr></table></figure><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>如果是与代码有冲突的注释还不如不写，对代码有改动时一定要优先更改注释来保持为最新状态<br><br>注释应该为多个完整的句子，如果是一个短语或一个句子，其首字母应该大写，除非是以小写字母开头的标识符（注意：永远不要更改标识符的大小写）<br><br>如果注释很短，结束的句号可以被忽略；块注释通常由一段或几段完整的句子组成，每个句子都应该以句号结束，末尾的句号后应该还要再加上2个空格，另外，建议注释还是用英文写，尽量不要是散装英语，不行就咱就百度翻译一下，coder English forever!</p><h2 id="块注释"><a href="#块注释" class="headerlink" title="块注释"></a>块注释</h2><p>块注释一般写在对应的代码块之前，并且与代码块拥有相同的缩进级。块注释的每一行以一个#和一个空格开头（除非注释内的文本都缩进），块注释内部的段落则只需要一个#开头  </p><h2 id="行内注释"><a href="#行内注释" class="headerlink" title="行内注释"></a>行内注释</h2><p>尽量少使用行内注释<br>行内注释与代码在同一行，至少使用两个空格分隔，同时也是用以一个#和一个空格开头，如果代码一眼就能看到是什么意思就没必要写行内注释（当然有时候也很有必要，结合实际情况）  </p><h2 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h2><p>这里补充一下相关知识——docstring：<br>在定义函数时，在函数内部编写文档字符串充当函数的说明，然后通过help()函数既可查看内容<br><br>如果要写出好的文档字符串(即“docstring”)，可以阅读PEP 257<br>建议为所有的公共模块、函数、类和方法编写文档字符串。非公共的方法可以不写，但是要有一定的描述注释，同时这个注释应该写在<em>def</em>语句之后<br><br>PEP 257 有好文档字符串规约。尤其注意，多行文档字符串结尾处的”””要单独占一行  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-string">&quot;&quot;&quot;Return a foobang</span><br><span class="hljs-string"></span><br><span class="hljs-string">Optional plotz says to frobnicate the bizbaz first.</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>对于单行文档字符串，可以把末尾的”””放在同一行  </p><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>Python库的命名规约比较乱，所以很难保持一致性，但当前还是有一些值得推荐的命名规则，新的模块和包（包括第三方框架），应当遵循这些标准。但是如果现有的库遵循了不同的代码风格，那就应该保持内部代码的风格一致性  </p><h2 id="首要原则"><a href="#首要原则" class="headerlink" title="首要原则"></a>首要原则</h2><p>用户可见的公共部分API，它的名称应该表达出使用(即用途)而不是实现</p><h2 id="描述：命名风格"><a href="#描述：命名风格" class="headerlink" title="描述：命名风格"></a>描述：命名风格</h2><p>现存在多个不同的命名风格，只要能识别出使用的是哪一套风格就OK了<br>以下是常见的命名风格：  </p><ul><li>b (单个小写字母)</li><li>B (单个大写字母)</li><li>lowercase(小写)</li><li>lower_case_with_underscores(带下划线小写)</li><li>UPPERCASE(大写)</li><li>UPPER_CASE_WITH_UNDERSCORES(带下划线大写)</li><li>CapitalizedWords (也叫做CapWords或者CamelCase驼峰命名法)，也被称作StudlyCaps</li><li>mixedCase (注意：与CapitalizedWords不同在于其首字母小写)</li><li>Capitalized_Words_With_Underscores (So Ugly！)<br>Note: 当CapWords里包含缩写时，将缩写部分的字母都大写，即HTTPServerError比HttpServerError要好  </li></ul><h2 id="规范：命名规约"><a href="#规范：命名规约" class="headerlink" title="规范：命名规约"></a>规范：命名规约</h2><h3 id="需要避免的命名"><a href="#需要避免的命名" class="headerlink" title="需要避免的命名"></a>需要避免的命名</h3><p>不要使用字符’l’（L的小写的字母），’O’（o大写的字母），或者’I’（i的大写的字母）来作为单个字符的变量名，因为在一些字体中这些字符和数字1和0无法区别开来。=如果不得不使用’l’时，可以使用’L’代替  </p><h3 id="ASCII兼容性"><a href="#ASCII兼容性" class="headerlink" title="ASCII兼容性"></a>ASCII兼容性</h3><p>标准库中使用的标识符必须与ASCII兼容  </p><h3 id="包和模块名"><a href="#包和模块名" class="headerlink" title="包和模块名"></a>包和模块名</h3><p>模块命名应短小，且为全小写。若下划线能提高可读性，也可以在模块名中使用。Python包命名也应该短小，且为全小写，但不应使用下划线<br>当使用C或C++写的扩展模块有相应的Python模块提供更高级的接口时（比如，更加面向对象），C/C++模块名以下划线开头（例如，_sociket）</p><h3 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h3><p>类名一般使用大驼峰（CapWords）命名法，即首字母大写<br>当接口有了文档说明，并且接口主要是被用来调用的话，也可以使用函数的命名规范<br>注意，对于内置的变量命名有一个单独的约定：大多数内置命名都是一个单词（或者两个一起使用的单词），而大驼峰(CapWords)只对异常命名和内置常量使用  </p><h3 id="类型变量名"><a href="#类型变量名" class="headerlink" title="类型变量名"></a>类型变量名</h3><p>PEP 484中引入的类型变量名一般用比较短的驼峰命名: T，AnyStr，Num 建议将后缀_co或_contra添加到用于声明相应的协变(covariant)和逆变(contravariant)的行为  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TypeVar<br><br>VT_co = TypeVar(<span class="hljs-string">&#x27;VT_co&#x27;</span>, covariant=<span class="hljs-literal">True</span>)<br>KT_contra = TypeVar(<span class="hljs-string">&#x27;KT_contra&#x27;</span>, contravariant=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="异常名"><a href="#异常名" class="headerlink" title="异常名"></a>异常名</h3><p>一般来说异常大部分是类，所以类的命名约定也适用于异常，不过如果异常是抛出的错误就可以在名字后面加上“Error”（其他情况可以类推）  </p><h3 id="全局变量名"><a href="#全局变量名" class="headerlink" title="全局变量名"></a>全局变量名</h3><p>（我们假设这些变量都只在同一个模块内部使用）这些约定同样也适用于函数命名<br><br>对于通过from M import *导入的模块，应该使用__all__机制来避免import全局变量，或者采用下划线前缀的旧版约定来命名全局变量，从而表明这些变量是“模块非公开”的  </p><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><p>函数命名基本要是小写，必要时使用下划线来提高可读性<br>如果已有代码风格是混合大小写时（比如threading.py），可以为了保留向后兼容性大小写混合  </p><h3 id="函数和方法参数"><a href="#函数和方法参数" class="headerlink" title="函数和方法参数"></a>函数和方法参数</h3><p>总使用self为实例方法的第一参数<br>总使用cls为类方法的第一个参数<br>如果函数参数名和保留关键字冲突时，相对于使用缩写或拼写简化，使用以下划线结尾的命名一般更好。如使用class_比clss更好（或许使用同义词避免这样的冲突是更好的方式）  </p><h3 id="方法名和实例变量"><a href="#方法名和实例变量" class="headerlink" title="方法名和实例变量"></a>方法名和实例变量</h3><p>使用函数命名的规则：单词小写，必要时使用下划线分开以提高可读性<br>仅对于非公开方法和变量命名在开头使用一个下划线<br>为避免和子类的命名冲突，可以使用两个下划线开头来触发Python的命名修饰机制<br></p><p>Python类名的命名修饰规则：如果类Foo有一个属性叫__a，则不能使用Foo.__a的方式访问该变量（有使用者可能仍然坚持使用Foo._Foo__a的方法访问）一般来说，两个下划线开头的命名方法仅用于避免与设计为子类的类中的属性名冲突  </p><p>Note：关于__names的使用也有一些争论（见下文）  </p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量通常是在模块处定义，全部大写并用下划线将单词分开。如：MAX_OVERFLOW和TOTAL  </p><h3 id="继承的设计"><a href="#继承的设计" class="headerlink" title="继承的设计"></a>继承的设计</h3><p>首先要永远区别类的方法和实例变量（属性）应该是公开的还是非公开的。如果有考虑不清楚的话，请选择非公开的；因为之后将非公开属性变为公开属性要容易些<br></p><p>公开属性是那些你希望和你定义的类无关的客户来使用的，并且确保不会出现向后不兼容的问题，非公开属性是那些不希望被第三方使用的部分，你可以不用保证非公开属性不会变化或被移除<br></p><p>如果熟悉C++很容易就联系到public和private，但是在这里没有使用private(私有)这个词，因为在Python里没有什么属性是真正私有的（这样设计省略了大量不必要的工作）<br></p><p>另一类属性属于子类API的一部分（如同C++里的protected）一些类是为继承设计的，要么扩展要么修改类的部分行为，当设计这样的类时，需要谨慎清楚地决定哪些属性是公开的，哪些属于子类API，哪些只会被你的基类调用<br></p><p>在记住上面这些东西后，还有一些python的指南：  </p><ul><li>公共属性不应该有前缀下划线</li><li>如果公开属性的名字和保留关键字有冲突，在属性名尾部加上一个下划线，这比采用缩写和简写更好（但是与这条规约冲突的是，在对任何变量和参数时，<em>cls</em>对表示类来说是一个更好的选择，特别是在类方法的第一个参数里）<blockquote><p>Note1：对于类方法，参考之前的参数命名</p></blockquote></li><li>对于简单的公共数据属性，最后仅公开属性名字，不要公开复杂的调用或设值方法。请记住，如果发现一个简单的数据属性需要成为功能行为时，Python为功能增强提供了一个简单的途径，这种情况下，使用Properties注解将功能实现隐藏在简单数据属性访问语法之后<blockquote><p>Note1: Properties注解仅仅对新风格类有用<br>Note2: 尽量保证功能行为没有副作用，虽然缓存这种副作用看上去并没有什么大问题<br>Note3：计算量较大的运算避免试用properties；属性的注解会让调用者相信访问的运算量是相对较小的</p></blockquote></li><li>如果类某个将被子类继承的话，且有一些属性并不想让子类访问，可以考虑将他们命名为两个下划线开头并且结尾处没有下划线。这样会触发Python命名修饰算法，类名会被修饰添加到属性名中。这样可以避免属性命名冲突，确保子类不会有相同的命名<blockquote><p>Note1：注意命名修饰仅仅是简单地将类名加入到修饰名中，如果子类有相同的类名和属性名，还是有可能会遇到命名冲突问题<br>Note2: 命名修饰可以有特定用途，比如在调试时，<strong>getattr</strong>()比较不方便。然而命名修饰算法的可以很好地记录，并且容意手动执行<br>Note3: 不是所有人都喜欢命名修饰，因此需要试着去平衡，以避免偶然命名冲突的需求和高级调用者使用的潜在可能性</p></blockquote></li></ul><p>注：这一段参考了多个翻译版本，有些许的拗口，感觉有用又感觉无用  </p><h2 id="公共与内部的接口"><a href="#公共与内部的接口" class="headerlink" title="公共与内部的接口"></a>公共与内部的接口</h2><p>任何的向后兼容性保证只适用于公共接口，因此，清晰地区分公共接口和内部接口是非常重要的<br><br>文档化的接口被认为是公开的，除非文档明确声明它们是临时或内部接口，不受到通常的向后兼容性保证，不然所有未记录的接口都应该是内部的<br><br>为了更好地支持内省（introspection），模块应该使用__all__属性显式地在它们的公共API中声明名称。将__all__设置为空列表表示模块没有公共API<br></p><p>即使通过__all__设置过，内部接口（包，模块，类，方法，属性或其他名字）依然需要单个下划线前缀<br><br>如果一个命名空间（包，模块，类）被认为是内部的，那么包含它的接口也应该被认为是内部的</p><h1 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h1><ul><li><p>代码应该以不影响其他Python实现（PyPy，Jython，IronPython，Cython，Psyco等）的方式编写</p></li><li><p>与单例作比较，像None应该用is或is not，永远不要用等号运算符(==)同样的，注意在写<em>if x</em>的时候，请注意是否表达的意思是<em>if x is not None</em>。例如，测试一个默认值为None的变量或参数是否设置成了其它值，其它值有可能是某种特殊类型（如容器），这种特殊类型在逻辑运算时其值会被当作Flase来看待</p></li><li><p>用is not操作符而不是not…is，虽然这两个表达式是功能相同的，前一个更可读，优先考虑</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br><span class="hljs-keyword">if</span> foo <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br><span class="hljs-comment"># No:</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> foo <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br></code></pre></td></tr></table></figure></li><li><p>始终使用def表达式来代替直接绑定了一个lambda表达式的赋值语句</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes:</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>):</span> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x<br><span class="hljs-comment"># No:</span><br>f = <span class="hljs-keyword">lambda</span> x: <span class="hljs-number">2</span>*x<br></code></pre></td></tr></table></figure></li><li><p>对于所有try/except子句，将try子句限制为必需的绝对最小代码量。这样可以避免屏蔽错误</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-keyword">try</span>:<br>    value = collection[key]<br><span class="hljs-keyword">except</span> KeyError:<br>    <span class="hljs-keyword">return</span> key_not_found(key)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> handle_value(value)<br><br><span class="hljs-comment"># No：</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># Too broad!</span><br>    <span class="hljs-keyword">return</span> handle_value(collection[key])<br><span class="hljs-keyword">except</span> KeyError:<br>    <span class="hljs-comment"># Will also catch KeyError raised by handle_value()</span><br>    <span class="hljs-keyword">return</span> key_not_found(key)<br></code></pre></td></tr></table></figure></li><li><p>当某个资源仅被特定代码段使用，用with语句确保其在使用后被立即干净的清除了，try/finally也是也接受的</p></li><li><p>坚持使用return语句。函数内的return语句都应该返回一个表达式或者None。如果一个return语句返回一个表达式，另一个没有返回值的应该用return None来清楚说明，并且在一个函数的结尾应该明确使用一个return语句（如果有返回值的话）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> math.sqrt(x)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><span class="hljs-keyword">return</span> math.sqrt(x)<br><br><span class="hljs-comment"># No：</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> math.sqrt(x)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> math.sqrt(x)<br></code></pre></td></tr></table></figure></li><li><p>对于序列（字符串、列表、元组）来说，空的序列为False</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> seq:<br><span class="hljs-keyword">if</span> seq:<br><br><span class="hljs-comment"># No：</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(seq):<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">len</span>(seq):<br></code></pre></td></tr></table></figure></li><li><p>不要让字符串对尾随的空格有依赖。这样的尾随空格是视觉上无法区分的，某些编辑器会自动去掉</p></li><li><p>不要用 == 去和True或者False比较</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># Yes：</span><br><span class="hljs-keyword">if</span> greeting:<br><span class="hljs-comment"># No：</span><br><span class="hljs-keyword">if</span> greeting == <span class="hljs-literal">True</span>:<br><span class="hljs-comment"># Worse：</span><br><span class="hljs-keyword">if</span> greeting <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br></code></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>虽然在使用pycharm的过程中我比较厌烦时不时出现的波浪线，但是我还是保留了默认的inspection设置，每一次波浪线提醒也是在变相的提醒自己是否有一个良好的编写风格<br><br>当然，有一个良好的风格固然重要，但是盲目的保持一致性也是一种不当的选择，更多的还是应该要是要根据项目本身的一致性风格，甚至于模块及函数中的风格一致性。这一点在官方文档的前言部分就有提到，例如：  </p><blockquote><p>In particular:do not break backwards compatibility just to comply with this PEP!</p></blockquote><p>最后，关于PEP 8现已有很多个中文翻译版本，如果只是出于阅读和学习的目的，就可以查看他人更加专业的翻译和总结，我自己选择过了一遍手是希望自己对其有一定的记忆性，然后在使用任何语言进行开发时都有一套自己的风格规范，以形成良好且规范的代码风格  </p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python Spider</title>
    <link href="/2021/08/09/python-spider/"/>
    <url>/2021/08/09/python-spider/</url>
    
    <content type="html"><![CDATA[<p>python网络爬虫与信息提取  </p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>python作为一门热门语言，本专业也开设有python课程（暂时还未上），曾经在参加建模的时候自学了一段时间的python，当时对基础语法进行了速成，通过现有的例子去模仿着来做一些简单的Excel处理，没有很系统的去学习这门语言，也是在那个时候了解到了爬虫和数据提取，当时就觉得爬取网页特别的有意思而且有很大的实际作用，于是，通过闲余的零碎时间在MOOC上通过<em>北京理工大学——python网络爬虫与信息提取</em>这门网课进行了简单的学习，并以本篇做下了笔记与记录  </p><h1 id="前奏"><a href="#前奏" class="headerlink" title="前奏"></a>前奏</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>百度百科定义：  </p><blockquote><p>API（Application Programming Interface，应用程序接口）是一些预先定义的接口（如函数、HTTP接口），或指软件系统不同组成部分衔接的约定。用来提供应用程序与开发人员基于某软件或硬件得以访问的一组例程，而又无需访问源码，或理解内部工作机制的细节<br>通过他人的一个生动例子来类似举例：<br>我的室友热爱刷B站，和广大冲浪选手一样喜欢看男孩子都爱看的，每当他看到了喜欢的就会默默加入自己的收藏夹（以便反复观摩和分享），那么我们其他人也喜欢看但是又没有他专业，那就只好关注他，然后再去他的收藏夹看就可以了，并且他还和我们说了一个“规矩”：看完后不要三连广泛传播，以便能长期看到更新<br>那么他的账号ID就是对于我们一个API，我们不需要知道他是怎么找到的，只需要从他的收藏夹默默观看就行，同时这个“规矩”就是我们和他完成这个交互操作所遵循的规则，即API协议  </p></blockquote><h2 id="所用工具"><a href="#所用工具" class="headerlink" title="所用工具"></a>所用工具</h2><p>IDE：Pycharm<br>接触和使用过很多的IDE，例如IDLE，vscode，sublime，eclipse，pycharm等等，一直以来能比较喜欢jetbrains那一套风格的IDE，所以pycharm为主力长期使用  </p><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><p>Requests是入门级使用最多HTTP第三方库，对内在模块进行了高度的封装，简单实用可以节省很大的工作量  </p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> requests                             <span class="hljs-comment">#import requests库</span><br>r = requests.get(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>)    <span class="hljs-comment">#get(URL)</span><br>r.encodeing                                 <span class="hljs-comment">#查看当前编码方式</span><br>r.apparent_encoding                         <span class="hljs-comment">#备选编码方式</span><br>r.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span>                        <span class="hljs-comment">#更改编码方式为utf-8</span><br>r.status_code                               <span class="hljs-comment">#http状态码，200表示OK</span><br>r.text                                      <span class="hljs-comment">#url对应的网络页面</span><br>r.content                                   <span class="hljs-comment">#http相应内容的二进制形式</span><br></code></pre></td></tr></table></figure><p>tip: requests.get(url,parmas=None,**kwargs)  </p><h3 id="通用代码框架"><a href="#通用代码框架" class="headerlink" title="通用代码框架"></a>通用代码框架</h3><p>有效的处理访问网页过程中出现的异常问题，使访问变得更有效，更可靠  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getHTMLText</span>(<span class="hljs-params">url</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>        r = requests.get(url, timeout=<span class="hljs-number">30</span>)<br>        r.raise_for_status()                <span class="hljs-comment"># 如果状态不是200，引发HTTPError异常</span><br>        r.encoding = r.apparent_encoding<br>        <span class="hljs-keyword">return</span> r.text<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;error&quot;</span><br></code></pre></td></tr></table></figure><h3 id="HTTP协议与requests常用方法"><a href="#HTTP协议与requests常用方法" class="headerlink" title="HTTP协议与requests常用方法"></a>HTTP协议与requests常用方法</h3><p>HTTP协议是一种基于“请求与响应”模式的、无状态的应用层协议；URL即通过HTTP协议存储资源的internet路径，一个URL对应一个数据资源<br><br>requests的七个主要用法：<br><img src="/img/python/requests.png"><br>requests库的主要7个方法中request方式则是所有方法的基础方法，并且与http的主要方法的用途是一致的<br><img src="/img/python/requests_and_http.png"></p><p>重点方法：requests.request(method,url,**kwargs)<br>method：请求方式，即”get”、”head”、”post”等<br>kwargs：控制访问的参数，为可选项，常用参数为：  </p><blockquote><p>params：字典或者字节序列，作为参数增加到url中<br>data：字典或者字节序列，作为参数增加到url中<br>json：json格式的数据，作为request的内容<br>headers：字典，http定制头<br>cookies：字典或者CookiesJar，request中的cookie<br>auth：元组，支持http认证功能<br>file：字典，传输文件<br>timeout：设定超时时间，以秒为单位<br>stream：true/false，默认为false，获取内如立即下载开关</p></blockquote><h2 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h2><p>对服务器上所能查看的内容进行一个协议规定，并不是规范而是约定俗成的，并不能保证隐私<br>存在：写在网站根目录下的robots.txt<br>基本语法：  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">User-agent:</span> <span class="hljs-string">*</span>       <span class="hljs-comment">#所有spider</span><br><span class="hljs-attr">Disallow:</span> <span class="hljs-string">/</span>         <span class="hljs-comment">#不允许方法的根目录</span><br></code></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h3><p>在对某些网站进行爬虫时，网站会根据检查访问的http头来是否是由一个爬虫引起的，因此则需要通过修改headers字段来将爬虫模拟成浏览器来对服务器进行一个http的请求进而实现访问<br>以亚马逊中国的某个电子书产品页面为例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">url = <span class="hljs-string">&quot;https://www.amazon.cn/dp/B099ZY9QPG&quot;</span><br><span class="hljs-keyword">try</span>:<br>    kv = &#123;<span class="hljs-string">&#x27;uers-agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0&#x27;</span>&#125;<br>    r = requests.get(url, headers=kv)<br>    r.raise_for_status()<br>    r.encoding = r.apparent_encoding<br>    <span class="hljs-built_in">print</span>(r.text[<span class="hljs-number">0</span>:<span class="hljs-number">1000</span>])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;spider error&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>搜索引擎一般会提供关键词提交接口，对requests库只需要通过parmas参数对url进行构造修改就可以实现关键词的提取<br>以百度为例<a href="http://www.baidu.com/s?**wd**=keyword">http://www.baidu.com/s?**wd**=keyword</a> ：  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">keyword = <span class="hljs-string">&quot;python&quot;</span><br><span class="hljs-keyword">try</span>:<br>    kv=&#123;<span class="hljs-string">&quot;wd&quot;</span>: keyword&#125;<br>    r=requests.get(<span class="hljs-string">&quot;http://www.baidu.com/s&quot;</span>,params=kv)<br>    <span class="hljs-built_in">print</span>(r.request.url)<br>    r.raise_for_status()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(r.text))<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> os                               <span class="hljs-comment"># os库实现文件的基本操作</span><br>url = <span class="hljs-string">&quot;https://nishuilema.top/img/profile_photo.jpg&quot;</span><br>root = <span class="hljs-string">&quot;E://&quot;</span><br>path = root + url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]        <span class="hljs-comment"># 截取url最后一个/后面的名字，即原图片名</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(root):<br>        os.mkdir(root)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(path):        <span class="hljs-comment"># 没有目录则新建</span><br>        r = requests.get(url)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            f.write(r.content)          <span class="hljs-comment"># 图片以二进制保存</span><br>            f.close()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save success&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file existed&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;spider error&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="ip归属地"><a href="#ip归属地" class="headerlink" title="ip归属地"></a>ip归属地</h3><p>通过ip138网站来实现对ip归属地的查找  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">url = <span class="hljs-string">&quot;https://www.ip138.com/ip.asp?ip=&quot;</span><br><span class="hljs-keyword">try</span>:<br>    r = requests.get(url+<span class="hljs-string">&#x27;219.153.130.78&#x27;</span>)      <span class="hljs-comment"># cqnu官方ip</span><br>    r.raise_for_status()<br>    r.encoding = r.apparent_encoding<br>    <span class="hljs-built_in">print</span>(r.text[-<span class="hljs-number">500</span>:])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-comment"># print(r.status_code)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;error&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h1><h2 id="Beautiful-Soup库入门"><a href="#Beautiful-Soup库入门" class="headerlink" title="Beautiful Soup库入门"></a>Beautiful Soup库入门</h2><p>Beautiful Soup库是解析、遍历、维护“标签树”的功能库<br>BeautifulSoup类对应一个HTML/XML文档的全部内容  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br>soup = BeautifulSoup(<span class="hljs-string">&#x27;&lt;p&gt;data&lt;p&gt;&#x27;</span>, <span class="hljs-string">&#x27;html.parser&#x27;</span>)  <span class="hljs-comment"># &#x27;html.parser&#x27;——简单的HTML解释器</span><br></code></pre></td></tr></table></figure><p><img src="/img/python/beautifulsoup1.png"></p><h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SE and UML</title>
    <link href="/2021/07/30/SE-and-UML/"/>
    <url>/2021/07/30/SE-and-UML/</url>
    
    <content type="html"><![CDATA[<p>软件工程导论与UML笔记</p><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇为期末复习时，对于所学的<code>UML面向对象建模与分析</code>与<code>软件工程导论</code>这两门课的一个复习笔记，笔记内容以老师所划重点为主<br><br>笔记原在<em>Notion</em>上面，起初是打算将笔记导出为md文件，在导出的过程遇到了些问题，例如若主页面导出后子页面仅为链接、子页面标题为中文就会出现”untitled”等英文字符串、内嵌图片无法正常显示、无法批量导出等等，通过在寻找解决办法的时候，在github找到了一个叫<a href="https://github.com/echo724/notion2md">notion2md</a>项目，利用python解决了导出为md文件的问题<br><br>但是我出于阅读的方便性和简洁性（懒）就放弃了导出为md文件再粘贴到本篇的这个方法，于是在此处就直接放上了<em>Notion</em>的链接  </p><h1 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h1><p>所用教材为<code>UML面向对象分析、建模与设计————吕云翔（清华大学出版社）</code><br><a href="https://southern-coral-508.notion.site/UML-352f3a0544f94557b17c2555ef578705">UML</a>  </p><h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><p>所用教材为<code>软件工程导论（第六版）————张海藩 牟永敏（清华大学出版社）</code><br><a href="https://southern-coral-508.notion.site/23419caea5f14baca9787ec8dd">软件工程导论</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2021/07/26/Git/"/>
    <url>/2021/07/26/Git/</url>
    
    <content type="html"><![CDATA[<p>关于Git的学习笔记与心得</p><span id="more"></span><h2 id="追溯"><a href="#追溯" class="headerlink" title="追溯"></a>追溯</h2><p>我在大二上开学的时候，学校有个一周的实训让我们做个小的项目，在要求里面提到了必须要使用git进行版本控制，因此这也算是我第一次正式的去了解到什么是版本控制，什么是git，也是从那时候学会了合理运用github（clone）<br>当时也是第一次接触做项目，在经过一定的（短暂的）学习后，最后还是只实现了在本地仓的一个版本控制，没有部署在github上实现同步，现在去看，就想当于做了个寂寞<br><img src="/img/Git/opensource.png"><br>在写这篇文章时，找到了当时的项目要求，有什么功能分析，模块组成等等，经过学习了软件工程导论和UML建模等课程之后，才知道当时写的那些东西是多么的业余，随着小项目的开发越来越多，慢慢发现到这些东西比写代码要重要数倍，期末大作业的时候老师也在不停的强调前期工作的重要性，我也实际开发过程中领会到了它们的魅力<br><br>回到正题，因为博客是采用的hexo和github page搭建的，在搭建和撰写过程中频繁用到了git，所以写下这篇文章来对git的学习进行一个记录和总结<br>tips：本篇涉及到的所有操作的所在环境为Windows，同时在翻阅现有教程的时候，在<a href="http://liaoxuefeng.com/">廖雪峰</a>关于Git的教程里提到了这样一点：</p><blockquote><p>千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbb（十六进制）的字符，你会遇到很多不可思议的问题。<br>比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费。</p></blockquote><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><h3 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h3><p>版本控制的百科解释：<br><code>版本控制是指对软件开发过程中各种程序代码、配置文件及说明文档等文件变更的管理，是软件配置管理的核心思想之一。</code><br>简单来说就是能够追溯文件的变更信息，同时通过版本控制中的分支和合并来用于并行开发<br><br>举个例子，例如我小时候爱玩的GTA，你在家偷偷玩电脑跑剧情，突然这时候听到你妈妈回来的声音，这时你就只能默默按下ESC进入设置存个档，然后火速关闭电脑拿上你心爱的课本，等你妈妈出门后，你再次打开读档继续玩，当然你英语很菜没理解到剧情任务，要保护npc结果你让他领盒饭了，任务失败了，这时候你只好默默的再次读档once again<br><br>版本控制简单分为<strong>集中式的版本控制</strong>和<strong>分布式的版本控制</strong>，其中集中式代表为历史悠久的CVS和SVN，分布式代表Git，如同他们的名字一样，一个是集中管理，一个是分布管理。<br><br><strong>集中式控制系统：</strong>有一个中央服务器，所有的版本库，即仓库（repository）都存在这里，开始工作要从这里把最新版本提取下来，结束工作后再把你的文件传上去。但是，它的操作过程需要联网，必须通过局域网或互联网才能将进行提取和上传。同时，在并行开发过程中也会出现提取版本不完整的问题<br><br><strong>分布式控制系统：</strong>它没有中央处理器，也不需要联网，每个人版本都是完整的，你只需要那你的版本推给你的伙伴，他就可以查看到你的修改信息了，同时获得最新版本。但是，在实际的项目开发过程中肯定有多个人，每个人都在更新同步自己的信息，就很容易乱套，因此，实际上也会存在一个“中央服务器”，不过这个服务器区别于集中式的中央服务器，它仅仅起到“交换”的作用，根据大家的信息来得到最新的版本，所以没有它也是可以正常工作的</p><h3 id="2-安装与创建"><a href="#2-安装与创建" class="headerlink" title="2.安装与创建"></a>2.安装与创建</h3><p><strong>安装</strong><br>Git的安装现有的教程已经不计其数了，无论你是哪种Linux，Mac还是Win都有详细到不行的步骤了，同时你在安装的过程中遇到的99.9%的问题都能查到答案<br><strong>创建</strong><br>首先，选择你喜欢一个盘，在里面建一个空文件夹来作为你建立仓库的地址，进入当前目录右键Git Bash，然后就可以建立你的本地仓</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean">mkdir gitdemo   ##你的仓库名<br>cd gitdemo      ##进入<br>pwd             ##查看当前路径<br>git init        ##在当前路径建立一个空的仓库<br></code></pre></td></tr></table></figure><p>建立你的过程非常简单，熟悉Linux命令操作的同学应该是游刃有余，然后在当前目前就会多一个.git的隐藏文件（后面会具体解释），如果没有则看是不是没打开查看隐藏文件的选项，当然你也可以通过<code>ls -ah</code>命令来查看。<br>tip：仓库的建立不一定是要空目录，有文件存在也是可以的<br><strong>添加文件</strong><br>一个好的项目的建立，少不了的就是readme文件，先建立一个txt文件命名为readme，熟悉Markdown可以直接撰写md文件，作为一个合格的打工人相信会快就会熟悉到Markdown语法的，这里附上<a href="https://markdown.com.cn/">官方教程</a>以便学习  </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">git add readme.txt                      ##add增加文件<br>git commit -m <span class="hljs-string">&quot;create readme file&quot;</span>      ##为增加的文件添加说明<br></code></pre></td></tr></table></figure><p>添加文件的过程很简单就两条命令，可以执行多个add命令后，再进行commit对提交的多个文件进行说明<br><br>tips：注意，除了<code>Git init</code>建立仓库以外的所有命令的执行都要在你的仓库主目录下进行，另外在Git Bash里面复制粘贴不再是Ctrl C和Ctrl V，而是<code>Ctrl insert</code>和<code>shift insert</code>   </p><h2 id="基本工作"><a href="#基本工作" class="headerlink" title="基本工作"></a>基本工作</h2><h3 id="1-工作区、暂存区和版本库"><a href="#1-工作区、暂存区和版本库" class="headerlink" title="1.工作区、暂存区和版本库"></a>1.工作区、暂存区和版本库</h3><p><strong>工作区：</strong>当前能看到的目录，如同gitdemo目录，你可以任意操作的地方<br><strong>暂缓区：</strong>也被称为Stage或者index，存于<code>.git</code>目录下的index文件，作用于文件修改后的一个暂存地方，来临时保存改动<br><strong>版本库：</strong>即<code>.git</code>目录，里面除了上文提到的暂存区以外，还包含有一个<code>master</code>分支以及指向<code>master</code>的指针<code>HEAD</code><br><img src="/img/Git/banbenku.jpg"><br>当对工作区的文件执行修改操作后执行<code>git add</code>命令后，文件的修改信息就会进入暂存区，然后执行<code>git commit</code>命令就把暂存区的内容提交到master分支，同时更新暂存区的目录树，而HEAD指针起到的作用就是充当目录树的一个标尺位置，这个地方我没有太去深究，简单来说，add把文件放到暂存区，commit把暂存区信息提交到master分支上，因此也解释了之前提到的可以多次add后，进行commit的一次性说明<br>tip：做出任何操作后都可以通过<code>git status</code>命令来查看状态</p><h3 id="2-历史版本"><a href="#2-历史版本" class="headerlink" title="2. 历史版本"></a>2. 历史版本</h3><p>当你进行多次修改后，可以通过<code>git log</code>命令来查看提交日志</p><blockquote><p>$ git log<br>commit 8ab0289d1dc801890391f9a1ccc0bca4d482b6d2 (HEAD -&gt; main, origin/main, origin/HEAD)<br>Author: anqi <a href="mailto:&#109;&#x69;&#110;&#x79;&#x61;&#111;&#97;&#x6e;&#x71;&#105;&#55;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;">&#109;&#x69;&#110;&#x79;&#x61;&#111;&#97;&#x6e;&#x71;&#105;&#55;&#x40;&#49;&#54;&#51;&#x2e;&#99;&#x6f;&#109;</a><br>Date:   Sun Jul 18 16:07:55 2021 +0800</p><p>   Create pages.jpg</p><p>commit af37ce5bcf7a2bc824dd710f8ae16c46f1f84797<br>Author: anqi <a href="mailto:&#x6d;&#x69;&#x6e;&#121;&#x61;&#111;&#97;&#110;&#113;&#x69;&#55;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;">&#x6d;&#x69;&#x6e;&#121;&#x61;&#111;&#97;&#110;&#113;&#x69;&#55;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Sun Jul 18 15:40:56 2021 +0800</p><p>  Update README.md</p></blockquote><p>这里就再次提到<code>HEAD</code>，Git中用<em>HEAD</em>表示当前版本，所以往上一个版本就是<em>HEAD^</em>，上上一个版本就是<em>HEAD^^</em>，以此类推，当倒退的版本代较远时，例如往前的第50个版本，也通过<code>HEAD~50</code>来表示<br><br>但是如果你回退到倒数第二个版本后，你又后悔了，想改回到倒数第一个版本怎么办，这时候看到<code>git log</code>里的commit后面跟着这一长串字符，其实它就为版本号（commit id），因此知道了每次提交的版本号那么我们就可以做到精准的版本回退，通过<code>git reset --hard commit id</code>命令就可以实现版本的回退，当然这里不需要把这么长的版本号都输入进去，只需要前面几位就会自己去寻找匹配到相应版本<br><br>等等，你突然发现，现在用<code>git log</code>查看也不会显示上次的倒数第一个版本的信息了，那怎么办呢，如果正好你是在刚版本回退完后，你的命令行窗口还没关，那么往上翻一翻就还是可以看到，但是你把它关掉了，或者过了一两天后才后悔的那又怎么办，Git早就把这些情况考虑到了，于是有<code>git reflog</code>命令来记录你的每一次命令操作，于是你就可以如同时间旅行者一样，从过去到未来  </p><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><p>删除操作是整个管理修改操作里很重要的一个操作，在日常的文件管理方面，如果你不想要某个文件，你就可以直接delete，把它丢进垃圾桶，在这里我们将文件分为两类，一类是工作区里的文件，一类是提交到版本库里的文件，我们以readme.md文件为例<br>假设现在你写了一个readme文件，然后执行了<code>git add readme.md</code>命令和<code>git commit -m &quot;add readme.md&quot;</code>命令，那么即是把文件提交到了版本库里，现在要把他删除掉，在工作区里右键删除或者执行<code>rm readme.md</code>命令然后在工作区就找不到它了，这时候Git就能知道当前工作区和版本库不一致了，通过<code>git status</code>命令它就能告诉你删除了什么文件所以可以得知我们并没有在版本库里删除这个文件<br><br>于是，这里又会分为两种情况，一种是你确定要从版本库里把它删除，一种是你不小心在工作区删除了，并且想要恢复文件<br>前者，先执行<code>git rm readme.md</code>命令，然后再<code>git commit -m &quot;delete readme.md&quot;</code>说明，类似于<code>git add</code>命令需要进行一个说明，不然连删了什么文件都不知道了<br>后者，可利用<code>git checkout -- readme.md</code>命令来恢复readme.md文件在版本库里的状态，<code>git checkout</code>是频繁使用命令之一，同时也是很危险的一个命令，它的实际作用就是将版本库的版本重写到工作区，具体有很多种用法，这里还是照样附上官方教程–<a href="http://git-scm.com/docs">Git</a>，任何东西学习最好还是以官方为准，毕竟他们是最权威的存在，当然英文看着也很头疼，刚开始也只能结合着其他人总结的中文教程来食用  </p><h3 id="4-撤销"><a href="#4-撤销" class="headerlink" title="4.撤销"></a>4.撤销</h3><p>在日常中删错了某个东西或者写错了一个东西，首先想到应该不是恢复它或者删掉它，而是Ctrl Z，我经常提到的一句话就是，万物Ctrl Z，没有什么撤销解决不了的（玩笑话）<br>参照上面的删除操作，这里将撤销分为三种情况：<br>第一种：如果是还在工作区操作，想撤销某个文件的修改操作，这里可以用上面的<code>git checkout -- &lt;file&gt;</code>命令来通过舍弃工作区来实现<br>第二种：如果是已经把文件add到了暂存区，我们则可以利用<code>git reset HEAD &lt;file&gt;</code>命令将暂存区的修改回退到工作区，然后再通过<code>git checkout -- &lt;file&gt;</code>命令舍弃工作区<br>第三种：文件add后也commit提交了，那么就只能坐上哆啦A梦的时光机回到之前的版本了  </p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>分支是版本控制中一个很重要的存在，它类似于游戏里的支线，比如之前玩的杀戮尖塔一进入地图就有很多路线选择，但是每条路通向最后一个终点，这里又让我想到了底特律，选择的分支不同还会出现不同的结局（以后一定不当云玩家），回到Git的分支也是一个道理，在多人协作的时候，我写我的分支，你写你的分支，互不干扰，最后我们再合并一下就可以了<br><br>通过<code>git branch</code>命令可以查看本地的分支存在情况  </p><blockquote><p>$ git branch<br>* master</p></blockquote><p>此处显示的<em>master</em>就是讲版本库的时候提到的<code>master</code>分支，即Git默认创建的主分支</p><h3 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1.基本操作"></a>1.基本操作</h3><p><strong>创建：</strong>  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git branch <span class="hljs-built_in">demo</span>     #创建一个名为<span class="hljs-built_in">demo</span>的分支<br>git checkout <span class="hljs-built_in">demo</span>   #切换到<span class="hljs-built_in">demo</span>分支<br></code></pre></td></tr></table></figure><p>这里也可直接用<code>git checkout -b demo</code>命令，来表示创建并切换到demo分支，然后再通过<code>git branch</code>就可以看到有<code>master</code>和<code>demo</code>两个分支<br><br>tip:发现这里<code>git checkout demo</code>的命令和之前讲删除撤销时用到的<code>git checkout -- &lt;file&gt;</code>命令很类似，这里要区别好<code>git checkout命令</code>的两种用途，在新版的Git里面也可以用<code>git switch -c &lt;name&gt;</code>命令来实现创建并切换到分支的操作，同理<code>git switch &lt;name&gt;</code>命令切换分支<br><br><strong>合并：</strong><br>当在demo分支上进行修改（add和commit）后，切回master分支，通过<code>git status</code>命令查看文件是没有状态改动的，现在需要把demo分支上的内容合并到master上来就只需执行<code>git marge demo</code>命令就可以了，master分支里的内容也会变得和demo上修改的一致<br><br><strong>删除：</strong><br>经过上面的合并操作后，demo分支已经完成了它的使命，那么就可以执行<code>git branch -d demo</code>命令把它删除，再通过<code>git branch</code>查看就只剩下<em>master</em>分支了<br>在实际开发过程中，将会有不同的功能的添加和测试，所以建议每个功能都建一个分支，然后再合并到主分支，但是如果出现已经完成了一个功能分支（还未合并），但是现在决定又要把它舍弃掉，如果执行<code>git branch -d</code>命令的话，则会出现error，并且会提示你该分支还未合并，删除则会丢失掉该分支，此时需要将参数d换成D进行强制删除：<code>git branch -D &lt;branch&gt;</code>  </p><h3 id="2-合并冲突"><a href="#2-合并冲突" class="headerlink" title="2.合并冲突"></a>2.合并冲突</h3><p>这里将合并冲突单独拿出来作为一个小标题，并不是它很难很复杂，而是因为它是合并这个过程中的一个重要存在<br>例如，当在两个不同分支demo1和demo2上对readme.md文件进行了不同的修改，如在demo1分支上在文件里写了<em>hello world</em>，在demo2分支上在文件里写的却是<em>hello git</em>，然后在两个分支上都提交（add与commit），最后切换到demo1分支执行<code>git merge demo2</code>将demo2分支合并到demo1分支上时，Git就很报merge fail的错误，提示在readme.md文件发生了冲突(conflict)  </p><blockquote><p>CONFLICT (content): Merge conflict in readme.md<br>merge failed; fix conflicts and then commit the result  </p></blockquote><p>这里通过<code>git status</code>命令也会告诉冲突发生的位置，要解决这个冲突，就只能手动的进入文件，Git会标识出具体的冲突内容  </p><blockquote><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>hello world<br>=======<br>hello git<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; demo2</p></blockquote><p>然后人为的选择你是要<em>hello world</em>还是要<em>hello git</em>，最后执行<code>git add readme.md</code>命令和<code>git commit -m &quot;conflict fixed&quot;</code>命令告诉Git我已经解决了冲突  </p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>日常生活中，手机里总是安装着许多的应用，社交、购物出行等等都已经离不开它们了，这些app也会频繁更新，在更新安装的过程中它就会告诉你是当前版本号更新到某某版本，例如从V3.45————V3.46，那么在Git里标签就是一个特别的提交快照，一个版本库的快照<br><br>一个标签的创建往往与commit在一块，只需要执行<code>git tag &lt;tagname&gt;</code>命令就可以创建成功，这里可以添加-a或者-m参数来为标签添加注释和说明<br>常用的命令还有:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span>                        <span class="hljs-title">#查看所有标签</span><br><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">&lt;tagname</span>&gt; commit id    <span class="hljs-comment">#对某个具体的commit id进行标签</span><br>git show <span class="hljs-tag">&lt;tagname&gt;</span>             <span class="hljs-comment">#查看标签对应版本的修改情况</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> <span class="hljs-tag">&lt;tagname&gt;</span>           <span class="hljs-comment">#删除标签</span><br></code></pre></td></tr></table></figure><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>前面提到的一系列操作都是在本地仓库的，在分布式版本控制系统中提到了一个用于交换的“服务器”，Git是可以自己搭建服务器，但是这个过程需要很多前提步骤，比如需要购买一个服务器，然后在部署配置等等，折腾这些对现在的学习来说是可以但没有必要的，那么将代码交付给托管平台则是最简单省事的选择了<br><br>github无疑是最佳选择，作为当下最流行的代码托管平台，如果连它都不知道，不会使用的话就根本算不上是一个程序员(打工人)<br>国内访问github往往会受到限制，加载等各方面都会很慢，甚至是访问不了，最简单的解决方案就是去整个梯子(vpn)，感觉这是每个coder应该必备的东西，多去看看外面的世界，增加眼界（狗头），市面上现有的梯子太多，我不做推荐，但是能免费的肯定会受到流量和网速的限制，没有什么是钱解决不来的，一个月只需要不到一杯奶茶的钱就可以搞定<br>当然也有其他方法，比如访问国内镜像源，添加插件等等，这些教程都能在网上找到<br><br>关于github的注册和简单的配置（建立仓库等）已经是很久之前的事情了，同样也是基础到不能再基础的东西了，对于这篇Git的笔记，在这里就直接省略掉  </p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>首先，先要把本地的Git与github连接起来，Git支持的是SSH协议，所以就需要在本地创建SSH key <code>ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</code><br>其中的<a href="mailto:&#120;&#120;&#120;&#64;&#120;&#120;&#120;&#x2e;&#x63;&#x6f;&#109;">&#120;&#120;&#120;&#64;&#120;&#120;&#120;&#x2e;&#x63;&#x6f;&#109;</a>为github注册账户的邮箱地址，命令执行后会生成<code>id_rsa</code>和<code>id_rsa.pub</code>文件，前者为私钥，后者为公钥，然后去到github页面，找到<code>Account settings</code>————<code>SSH Keys</code>，再点击<code>Add SSH Key</code>，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，最后add key就完成了本地的Git与github连接<br>tip:可以通过<code>ssh -T git@github.com</code>命令验证是否连接成功  </p><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>建立远程仓库就要先在github上new repository，如图找到该仓库的SSH<br><img src="/img/Git/ssh.jpg"><br>然后执行<code>git remote add origin git@github.com:anqi399/blog.git</code>命令就可以在该仓库建立本地库的远程库<br>再执行<code>git push -u origin master</code>命令就可以把本地master分支的内容同步到github的仓库上<br><br>tip：第一次push带有<code>-u</code>参数，是因为远程仓库为空，以便本地的master分支与远程仓库的master更好的关联，以后只需执行<code>git push origin master</code>命令即可，另外<code>origin</code>只是默认的习惯命名，可以改成自己的任意命名  </p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p><strong>查看：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> remote      <span class="hljs-comment">#查看已有的远程仓库</span><br>git remote -v   <span class="hljs-comment">#详细查看出对应的地址</span><br></code></pre></td></tr></table></figure><p><strong>删除：</strong><br>执行<code>git remote rm &lt;name&gt;</code>命令可以解除本地和远程仓库的连接，而并非真正的删除，真正的删除还需要去远程仓库delete  </p><h3 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h3><p>这一步是我至今为止最熟悉也最常用的，相信也是你们最熟悉的步骤<br>通过以下两个命令都是可以的  </p><pre><code>git clone SSH                               #这里的SSH即你要clone的仓库的SSHgit clone https://github.com/xxx/xxx.git    #这里的地址即你要clone的仓库的网页地址</code></pre><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><p>当在本地完成了修改后，执行<code>git push origin master</code>将本地的master推送到远程仓库的origin  </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>学习是一个既枯燥又有趣的过程，摄入知识的过程是枯燥的，通过实践解决问题的过程是有趣又富有成就感的，经过几天的零碎时间最终才写成了这篇笔记，关于Git本篇所涉及的内容还很片面，也有很多不足的地方，谈不上达到了教程的要求，仅仅是给自己的学习留下点痕迹与记录<br>欢迎通过私信邮箱指正！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Blog</title>
    <link href="/2021/07/21/Blog/"/>
    <url>/2021/07/21/Blog/</url>
    
    <content type="html"><![CDATA[<p>精于基础 广于实现  </p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我在刷知乎的时候，看到了一篇关于计算机专业出身的学生应该怎样去学习知识的文章，其中的一个答主在问答里提到了标题的这八个字。当时就给我了很深的感触，我连忙把这几个字记了下来，以作为我的博客生涯的前言。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Blog的搭建过程，记录在我的github上<strong>Blog</strong>的仓库里，后续也会更新在使用过程过程出现的问题，以便记录  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/17/hello-world/"/>
    <url>/2021/07/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
